<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NeuroMed AI — Local Voice Dev Client</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 24px; color:#111; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin: 6px 0 12px; }
    button { padding:8px 12px; border-radius:8px; border:1px solid #ccc; background:#fafafa; cursor:pointer; }
    button.primary { background:#0b74ff; color:#fff; border-color:#0b74ff; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input[type=text] { padding:8px 10px; border-radius:8px; border:1px solid #bbb; width:420px; max-width:90vw; }
    #meterWrap { width:240px; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
    #meter { height:100%; width:0%; background:#0b74ff; transition: width .05s linear; }
    #log { white-space: pre-wrap; background:#0b0b0b; color:#cce3ff; padding:12px; border-radius:8px; min-height:160px; max-height:40vh; overflow:auto; font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, monospace; }
    .tag { display:inline-block; padding:2px 6px; font-size:11px; border-radius:999px; background:#eef3ff; color:#0b74ff; border:1px solid #dbe7ff; }
    .sep { height:1px; background:#eee; margin:16px 0; }
    small { color:#555 }
  </style>
</head>
<body>
  <h1>NeuroMed AI — Local Voice Dev Client</h1>
  <div class="row">
    <label for="ws">WS URL</label>
    <input id="ws" type="text" />
    <button id="connect" class="primary">Connect</button>
    <span id="connState" class="tag">disconnected</span>
  </div>
  <div class="row">
    <button id="start" disabled>Start Mic</button>
    <button id="stop" disabled>Stop Mic</button>
    <div id="meterWrap"><div id="meter"></div></div>
  </div>
  <div class="row">
    <button id="greet" disabled>Send Greeting</button>
    <button id="hangup" disabled>Send Stop</button>
  </div>
  <div class="sep"></div>
  <div id="log"></div>
  <p><small>
    This client emulates Twilio Media Streams: 8 kHz µ-law, 20 ms frames (160 bytes).  
    Your server should be listening on <code>/ws/twilio</code> and accept Twilio-shaped JSON.
  </small></p>

<script>
(() => {
  const WS_URL_DEFAULT = "ws://localhost:8080/ws/twilio"; // change if needed
  const wsInput = document.getElementById('ws');
  wsInput.value = WS_URL_DEFAULT;

  const btnConnect = document.getElementById('connect');
  const btnStart   = document.getElementById('start');
  const btnStop    = document.getElementById('stop');
  const btnGreet   = document.getElementById('greet');
  const btnHangup  = document.getElementById('hangup');
  const connState  = document.getElementById('connState');
  const logEl      = document.getElementById('log');
  const meterEl    = document.getElementById('meter');

  // ---- logging helpers ----
  function log(...args) {
    const ts = new Date().toISOString().split('T')[1].replace('Z','');
    logEl.textContent += `[${ts}] ${args.join(' ')}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setConn(tag, color) {
    connState.textContent = tag;
    connState.style.background = color ? color.bg : '';
    connState.style.color = color ? color.fg : '';
    connState.style.borderColor = color ? color.border : '';
  }

  // ---- WS state ----
  let ws = null;
  let streamSid = null;
  let callSid = null;
  let sending = false;

  // ---- Audio state ----
  let ac = null;
  let micNode = null;
  let procNode = null; // ScriptProcessorNode for capture
  let playbackNode = null; // ScriptProcessorNode for playback
  let sourceStream = null;
  let sendTimer = null;

  // Circular buffer for encoded µ-law outbound
  const OUT_CAP = 48000; // big enough ring
  let outBuf = new Int16Array(OUT_CAP); // we’ll build 8k PCM S16 then µ-law
  let outWrite = 0, outRead = 0, outCount = 0;

  // Playback queue for inbound µ-law → float PCM at 48k
  const PLAY_CAP = 48000 * 4; // ~4s max
  let playBuf = new Float32Array(PLAY_CAP);
  let playWrite = 0, playRead = 0, playCount = 0;

  // ---- Audio utils ----

  // Downsample Float32 @48k from mic to Int16 @8k (simple decimate with FIR-lite averaging)
  function downsample48kTo8k(float48) {
    // 48k -> 8k = factor 6
    const N = Math.floor(float48.length / 6);
    const out = new Int16Array(N);
    for (let i = 0, j = 0; i < N; i++, j += 6) {
      // simple average of the 6 samples (very small FIR smoothing)
      let s = (float48[j] + float48[j+1] + float48[j+2] + float48[j+3] + float48[j+4] + float48[j+5]) / 6;
      // clamp
      if (s > 1) s = 1; else if (s < -1) s = -1;
      out[i] = (s * 0x7FFF) | 0;
    }
    return out;
  }

  // µ-law encode/decode (G.711)
  function linear2ulaw(sample) {
    const BIAS = 0x84;
    const CLIP = 32635;
    let sign = (sample < 0) ? 0x7F : 0xFF;
    if (sample < 0) sample = -sample;
    if (sample > CLIP) sample = CLIP;
    sample = sample + BIAS;
    let exponent = 7;
    for (let expMask = 0x4000; (sample & expMask) === 0 && exponent > 0; expMask >>= 1) {
      exponent--;
    }
    const mantissa = (sample >> ((exponent === 0) ? 4 : (exponent + 3))) & 0x0F;
    const ulawByte = ~(sign & (exponent << 4 | mantissa));
    return ulawByte & 0xFF;
  }
  function ulaw2linear(uVal) {
    uVal = ~uVal;
    let sign = (uVal & 0x80);
    let exponent = (uVal >> 4) & 0x07;
    let mantissa = uVal & 0x0F;
    let sample = ((mantissa << 4) + 0x08) << (exponent + 3);
    sample -= 0x84;
    return (sign ? -sample : sample);
  }

  function enqueueOutboundPCM(int16_8k) {
    for (let i = 0; i < int16_8k.length; i++) {
      if (outCount >= OUT_CAP) { // drop if overflow
        // move read pointer forward (drop oldest)
        outRead = (outRead + 1) % OUT_CAP;
        outCount--;
      }
      outBuf[outWrite] = int16_8k[i];
      outWrite = (outWrite + 1) % OUT_CAP;
      outCount++;
    }
  }

  function popUlawFrame160() {
    if (outCount < 160) return null;
    const frame = new Uint8Array(160);
    for (let i = 0; i < 160; i++) {
      const s = outBuf[outRead];
      outRead = (outRead + 1) % OUT_CAP;
      outCount--;
      frame[i] = linear2ulaw(s);
    }
    return frame;
  }

  // Playback queue ops
  function enqueuePlaybackFloat48k(float48) {
    for (let i = 0; i < float48.length; i++) {
      if (playCount >= PLAY_CAP) {
        playRead = (playRead + 1) % PLAY_CAP;
        playCount--;
      }
      playBuf[playWrite] = float48[i];
      playWrite = (playWrite + 1) % PLAY_CAP;
      playCount++;
    }
  }
  function dequeuePlayback(target) {
    const n = Math.min(target.length, playCount);
    for (let i = 0; i < n; i++) {
      target[i] = playBuf[playRead];
      playRead = (playRead + 1) % PLAY_CAP;
      playCount--;
    }
    for (let i = n; i < target.length; i++) target[i] = 0;
  }

  // Simple peak meter
  function updateMeter(chunk) {
    let peak = 0;
    for (let i = 0; i < chunk.length; i += 32) {
      const v = Math.abs(chunk[i]);
      if (v > peak) peak = v;
    }
    const pct = Math.min(100, Math.floor(peak * 120));
    meterEl.style.width = pct + "%";
  }

  // ---- WS send helpers (Twilio-shaped) ----
  function b64(bytes) {
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  function sendStart() {
    streamSid = "DEV-" + Math.random().toString(36).slice(2, 10);
    callSid   = "DEV-CALL-" + Math.random().toString(36).slice(2, 8);
    const payload = {
      event: "start",
      start: {
        streamSid,
        // Twilio would provide these—your server only really needs the streamSid
        accountSid: "AC_DEVELOPMENT",
        callSid,
        tracks: ["inbound", "outbound"],
        mediaFormat: { encoding: "audio/ulaw", sampleRate: 8000, channels: 1 },
      }
    };
    ws.send(JSON.stringify(payload));
    log("WS ▶ sent start streamSid=", streamSid);
  }

  function sendStop() {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ event: "stop", streamSid }));
    log("WS ▶ sent stop");
  }

  function sendMediaFrame(frameUlaw160) {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({
      event: "media",
      streamSid,
      media: { payload: b64(frameUlaw160) }
    }));
  }

  // ---- Connect / Disconnect ----
  btnConnect.onclick = async () => {
    if (ws && ws.readyState === 1) {
      ws.close(1000, "client closing");
      return;
    }
    const url = wsInput.value.trim();
    ws = new WebSocket(url);
    setConn("connecting…", {bg:"#fff6e6", fg:"#9a6b00", border:"#ffe1a3"});
    log("WS ▶ connecting to", url);

    ws.onopen = () => {
      setConn("connected", {bg:"#e9fff0", fg:"#006d3c", border:"#b9f0cc"});
      log("WS ▶ open");
      btnConnect.textContent = "Disconnect";
      btnStart.disabled = false;
      btnGreet.disabled = false;
      btnHangup.disabled = false;
      sendStart();
    };

    ws.onclose = (e) => {
      setConn("disconnected");
      log("WS ▶ close code=", e.code, "reason=", e.reason);
      btnConnect.textContent = "Connect";
      btnStart.disabled = true;
      btnStop.disabled = true;
      btnGreet.disabled = true;
      btnHangup.disabled = true;
      stopMic();
    };

    ws.onerror = (e) => {
      setConn("error", {bg:"#ffe9e9", fg:"#8b0000", border:"#ffbdbd"});
      log("WS ▶ error", e?.message || "");
    };

    ws.onmessage = (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        if (msg.event === "media" && msg.media?.payload) {
          // inbound TTS from your server (µ-law @8k)
          const bytes = atob(msg.media.payload);
          const N = bytes.length;
          const f8k = new Float32Array(N);
          for (let i = 0; i < N; i++) {
            const s16 = ulaw2linear(bytes.charCodeAt(i));
            f8k[i] = Math.max(-1, Math.min(1, s16 / 32768));
          }
          // upsample 8k -> 48k (factor 6) by sample hold (simple, low-latency)
          const f48 = new Float32Array(N * 6);
          for (let i = 0; i < N; i++) {
            const v = f8k[i];
            const base = i * 6;
            f48[base] = v; f48[base+1] = v; f48[base+2] = v;
            f48[base+3] = v; f48[base+4] = v; f48[base+5] = v;
          }
          enqueuePlaybackFloat48k(f48);
        } else if (msg.event === "start") {
          log("WS ▶ server start ack", JSON.stringify(msg));
        } else if (msg.event === "stop") {
          log("WS ▶ server stop");
        } else if (msg.event) {
          log("WS ▶", msg.event, JSON.stringify(msg).slice(0, 160) + "…");
        } else {
          // some servers might just stream payloads without event
          // ignore silently
        }
      } catch (err) {
        // if server sends non-json, ignore
      }
    };
  };

  btnHangup.onclick = () => {
    if (ws && ws.readyState === 1) {
      sendStop();
    }
  };

  btnGreet.onclick = () => {
    // optionally resend a "start" (your server greets on start)
    if (ws && ws.readyState === 1) {
      sendStart();
    }
  };

  // ---- Mic pipeline ----
  async function startMic() {
    if (sending) return;
    ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
    sourceStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
    const src = ac.createMediaStreamSource(sourceStream);

    // capture via ScriptProcessorNode (1024/2048/4096 buffer)
    procNode = ac.createScriptProcessor(4096, 1, 1);
    procNode.onaudioprocess = (e) => {
      const ch0 = e.inputBuffer.getChannelData(0);
      updateMeter(ch0);
      const s8k = downsample48kTo8k(ch0); // Int16 @8k
      enqueueOutboundPCM(s8k);
    };

    // playback node pulls from queue and writes to output
    playbackNode = ac.createScriptProcessor(1024, 1, 1);
    playbackNode.onaudioprocess = (e) => {
      const out = e.outputBuffer.getChannelData(0);
      dequeuePlayback(out);
    };

    src.connect(procNode);
    procNode.connect(ac.destination); // not strictly needed, but keeps node alive
    playbackNode.connect(ac.destination);

    // send a 20 ms frame (160 samples @8k) every 20 ms
    sendTimer = setInterval(() => {
      if (!ws || ws.readyState !== 1 || !streamSid) return;
      const frame = popUlawFrame160();
      if (frame) sendMediaFrame(frame);
    }, 20);

    sending = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    log("AUDIO ▶ mic started");
  }

  function stopMic() {
    sending = false;
    if (sendTimer) { clearInterval(sendTimer); sendTimer = null; }
    try { if (procNode) procNode.disconnect(); } catch {}
    try { if (playbackNode) playbackNode.disconnect(); } catch {}
    try { if (micNode) micNode.disconnect(); } catch {}
    if (sourceStream) {
      sourceStream.getTracks().forEach(t => t.stop());
      sourceStream = null;
    }
    if (ac) { ac.close(); ac = null; }
    btnStart.disabled = false;
    btnStop.disabled = true;
    log("AUDIO ▶ mic stopped");
  }

  btnStart.onclick = startMic;
  btnStop.onclick  = stopMic;
})();
</script>
</body>
</html>
